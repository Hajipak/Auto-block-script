-- Auto Block Rayfield Script (Full Features) with Mobile Keybind Support
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local lp = Players.LocalPlayer
local PlayerGui = lp:WaitForChild("PlayerGui")
local Humanoid, Animator
local StarterGui = game:GetService("StarterGui")
local TestService = game:GetService("TestService")
local ChatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
local SayMessageRequest = ChatEvents and ChatEvents:FindFirstChild("SayMessageRequest")

-- Keybind variables
local autoBlockKey = Enum.KeyCode.A -- Default keybind for Auto Block
local isKeyPressed = false
local keybindEnabled = false -- Toggle untuk keybind controller
local mobileButton = nil -- Untuk tombol mobile
local mobileButtonEnabled = true -- Toggle untuk tombol mobile

-- Function to handle key press
local function onInputBegan(input, gameProcessed)
    if gameProcessed then return end
    
    if keybindEnabled and input.KeyCode == autoBlockKey then
        isKeyPressed = true
        if autoBlockAudioOn then
            autoBlockOn = true
            -- Notifikasi saat auto block diaktifkan
            StarterGui:SetCore("SendNotification", {
                Title = "Auto Block",
                Text = "ENABLED",
                Duration = 1
            })
        end
    end
end

-- Function to handle key release
local function onInputEnded(input, gameProcessed)
    if gameProcessed then return end
    
    if keybindEnabled and input.KeyCode == autoBlockKey then
        isKeyPressed = false
        autoBlockOn = false
        -- Notifikasi saat auto block dinonaktifkan
        StarterGui:SetCore("SendNotification", {
            Title = "Auto Block",
            Text = "DISABLED",
            Duration = 1
        })
    end
end

-- Function untuk membuat tombol mobile
local function createMobileButton()
    if mobileButton then return end
    
    mobileButton = Instance.new("TextButton")
    mobileButton.Name = "AutoBlockButton"
    mobileButton.Size = UDim2.new(0, 80, 0, 80)
    mobileButton.Position = UDim2.new(0.5, -40, 0.8, 0)
    mobileButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    mobileButton.BackgroundTransparency = 0.3
    mobileButton.Text = "A"
    mobileButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    mobileButton.TextScaled = true
    mobileButton.Font = Enum.Font.SourceSansBold
    mobileButton.Parent = PlayerGui
    mobileButton.ZIndex = 10
    mobileButton.Active = true
    mobileButton.Draggable = true
    
    -- Membuat sudut membulat
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 15)
    corner.Parent = mobileButton
    
    -- Membuat stroke
    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(255, 255, 255)
    stroke.Parent = mobileButton
    
    -- Event untuk tombol
    mobileButton.TouchBegan:Connect(function()
        if keybindEnabled and autoBlockAudioOn then
            autoBlockOn = not autoBlockOn
            isKeyPressed = autoBlockOn
            
            -- Notifikasi dan perubahan warna
            if autoBlockOn then
                mobileButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                StarterGui:SetCore("SendNotification", {
                    Title = "Auto Block",
                    Text = "ENABLED",
                    Duration = 1
                })
            else
                mobileButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                StarterGui:SetCore("SendNotification", {
                    Title = "Auto Block",
                    Text = "DISABLED",
                    Duration = 1
                })
            end
        end
    end)
    
    -- Event untuk mengubah keybind (tap dan tahan)
    local holdTime = 0
    local holdConnection
    
    mobileButton.TouchBegan:Connect(function()
        holdTime = tick()
        holdConnection = RunService.Heartbeat:Connect(function()
            if tick() - holdTime > 1 then -- Tahan selama 1 detik
                -- Buka dialog untuk mengubah keybind
                changeKeybindDialog()
                holdConnection:Disconnect()
            end
        end)
    end)
    
    mobileButton.TouchEnded:Connect(function()
        if holdConnection then
            holdConnection:Disconnect()
        end
    end)
end

-- Function untuk dialog mengubah keybind
local function changeKeybindDialog()
    -- Membuat frame dialog
    local dialog = Instance.new("Frame")
    dialog.Name = "KeybindDialog"
    dialog.Size = UDim2.new(0, 300, 0, 200)
    dialog.Position = UDim2.new(0.5, -150, 0.5, -100)
    dialog.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    dialog.Parent = PlayerGui
    dialog.ZIndex = 20
    
    -- Membuat sudut membulat
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 10)
    corner.Parent = dialog
    
    -- Judul
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, 0, 0, 40)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundTransparency = 1
    title.Text = "Change Keybind"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextScaled = true
    title.Font = Enum.Font.SourceSansBold
    title.Parent = dialog
    
    -- Tombol-tombol keybind
    local keybinds = {
        {name = "A", key = Enum.KeyCode.A},
        {name = "B", key = Enum.KeyCode.B},
        {name = "C", key = Enum.KeyCode.C},
        {name = "X", key = Enum.KeyCode.X},
        {name = "Y", key = Enum.KeyCode.Y},
        {name = "Z", key = Enum.KeyCode.Z},
        {name = "Space", key = Enum.KeyCode.Space},
        {name = "Shift", key = Enum.KeyCode.LeftShift}
    }
    
    local buttonHeight = 30
    local buttonSpacing = 5
    local startY = 50
    
    for i, keybind in ipairs(keybinds) do
        local button = Instance.new("TextButton")
        button.Name = "Keybind_" .. keybind.name
        button.Size = UDim2.new(1, -20, 0, buttonHeight)
        button.Position = UDim2.new(0, 10, 0, startY + (i-1) * (buttonHeight + buttonSpacing))
        button.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
        button.Text = keybind.name
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.TextScaled = true
        button.Font = Enum.Font.SourceSans
        button.Parent = dialog
        
        -- Sudut membulat
        local btnCorner = Instance.new("UICorner")
        btnCorner.CornerRadius = UDim.new(0, 5)
        btnCorner.Parent = button
        
        -- Event saat tombol ditekan
        button.TouchBegan:Connect(function()
            autoBlockKey = keybind.key
            mobileButton.Text = keybind.name
            
            -- Notifikasi
            StarterGui:SetCore("SendNotification", {
                Title = "Keybind Changed",
                Text = "New keybind: " .. keybind.name,
                Duration = 2
            })
            
            -- Update UI
            KeybindTab:CreateParagraph({
                Title = "Current Keybind",
                Content = keybind.name
            })
            
            -- Hapus dialog
            dialog:Destroy()
        end)
    end
    
    -- Tombol close
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -35, 0, 5)
    closeButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextScaled = true
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.Parent = dialog
    
    -- Sudut membulat untuk close button
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 5)
    closeCorner.Parent = closeButton
    
    closeButton.TouchBegan:Connect(function()
        dialog:Destroy()
    end)
end

-- Connect input functions
UserInputService.InputBegan:Connect(onInputBegan)
UserInputService.InputEnded:Connect(onInputEnded)

-- Create mobile button on start
if UserInputService.TouchEnabled then
    createMobileButton()
end

-- Handle character added (for mobile button)
lp.CharacterAdded:Connect(function()
    if UserInputService.TouchEnabled and mobileButtonEnabled then
        createMobileButton()
    end
end)

-- Place in ReplicatedFirst (LocalScript

-- Continue script 
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
local Window = Rayfield:CreateWindow({
Name = "Auto Block Hub",
LoadingTitle = "Auto Block Script",
LoadingSubtitle = "by Skibidi Shots",
ConfigurationSaving = {
Enabled = true,
FolderName = "AutoBlockHub",
FileName = "Settings"
},
Discord = {Enabled = false},
KeySystem = false
})

local NoticeTab = Window:CreateTab("Notice", 4483362458)
local AutoBlockTab = Window:CreateTab("Auto Block", 4483362458)
local BDTab = Window:CreateTab("Better Detection", 4483362458)
local TechTab = Window:CreateTab("Techs", 4483362458)
local PredictiveTab = Window:CreateTab("Predictive Auto Block", 4483362458)
local FakeBlockTab = Window:CreateTab("Fake Block", 4483362458)
local AutoPunchTab = Window:CreateTab("Auto Punch", 4483362458)
local CustomAnimationsTab = Window:CreateTab("Custom Animations", 4483362458)
local MiscTab = Window:CreateTab("Misc", 4483362458)
local KeybindTab = Window:CreateTab("Keybind", 4483362458)

-- IDs.
local autoBlockTriggerSounds = {
    ["102228729296384"] = true,
    ["140242176732868"] = true,
    ["112809109188560"] = true,
    ["136323728355613"] = true,
    ["115026634746636"] = true,
    ["84116622032112"] = true,
    ["108907358619313"] = true,
    ["127793641088496"] = true,
    ["86174610237192"] = true,
    ["95079963655241"] = true,
    ["101199185291628"] = true,
    ["119942598489800"] = true,
    ["84307400688050"] = true,
    ["113037804008732"] = true,
    ["105200830849301"] = true,
    ["75330693422988"] = true,
    ["82221759983649"] = true,
    ["81702359653578"] = true,
    ["108610718831698"] = true,
    ["112395455254818"] = true,
    ["109431876587852"] = true,
    ["109348678063422"] = true,
    ["85853080745515"] = true,
    ["12222216"] = true,
    ["105840448036441"] = true,
    ["114742322778642"] = true,
}

-- Prevent repeated aim triggers for the same animation track
local lastAimTrigger = {}   -- keys = AnimationTrack, value = timestamp when we triggered
local AIM_WINDOW = 0.5      -- how long to aim (seconds)
local AIM_COOLDOWN = 0.6    -- don't retrigger within this many seconds

-- add once, outside the RenderStepped loop
local _lastPunchMessageTime = _lastPunchMessageTime or 0
local MESSAGE_PUNCH_COOLDOWN = 0.6 -- overall throttle (seconds)
local _punchPrevPlaying = _punchPrevPlaying or {} -- persist between frames

local _lastBlockMessageTime = _lastBlockMessageTime or 0
local MESSAGE_BLOCK_COOLDOWN = 0.6 -- overall throttle (seconds)
local _blockPrevPlaying = _blockPrevPlaying or {} -- persist between frames

local autoBlockTriggerAnims = {
    "126830014841198", "126355327951215", "121086746534252", "18885909645",
    "98456918873918", "105458270463374", "83829782357897", "125403313786645",
    "118298475669935", "82113744478546", "70371667919898", "99135633258223",
    "97167027849946", "109230267448394", "139835501033932", "126896426760253",
    "109667959938617", "126681776859538", "129976080405072", "121293883585738",
    "81639435858902", "137314737492715",
    "92173139187970"
}

-- State Variables
local autoBlockOn = false
local autoBlockAudioOn = false
local doubleblocktech = false
local looseFacing = true
local detectionRange = 18
local messageWhenAutoBlockOn = false
local messageWhenAutoBlock = ""
local Debris = game:GetService("Debris")
-- Anti-flick toggle state
local antiFlickOn = false
-- how many anti-flick parts to spawn (default 4)
local antiFlickParts = 4

-- optional: base distance in front of killer for the first part
local antiFlickBaseOffset = 2.7

-- optional: distance step between successive parts
local antiFlickOffsetStep = 0

local antiFlickDelay = 0 -- seconds to wait before parts spawn (default 0 = instant)
local PRED_SECONDS_FORWARD = 0.25   -- seconds ahead for linear prediction
local PRED_SECONDS_LATERAL  = 0.18  -- seconds ahead for lateral prediction
local PRED_MAX_FORWARD      = 6     -- clamp (studs)
local PRED_MAX_LATERAL      = 4     -- clamp (studs)
local ANG_TURN_MULTIPLIER   = 0.6   -- how much angular velocity contributes to lateral offset
local SMOOTHING_LERP        = 0.22  -- smoothing for sampled velocity/angular vel

local killerState = {} -- [model] = { prevPos, prevLook, vel(Vector3), angVel(number) }

-- prediction multiplier: 1.0 is normal, up to 10.0
-- prediction multipliers
local predictionStrength = 1        -- forward/lateral (1x .. 10x)
local predictionTurnStrength = 1    -- turning strength (1x .. 10x)
-- multiplier for blue block parts size (1.0 = default)
local blockPartsSizeMultiplier = 1

local autoAdjustDBTFBPS = false
local _savedManualAntiFlickDelay = antiFlickDelay or 0 -- keep user's manual value when toggle is turned off

-- map of killer name (lowercase) -> antiFlickDelay value you requested
local killerDelayMap = {
    ["c00lkidd"] = 0,
    ["jason"]    = 0.013,
    ["slasher"]  = 0.01,
    ["1x1x1x1"]  = 0.15,
    ["johndoe"]  = 0.33,
    ["noli"]     = 0.15,
}

local predictiveBlockOn = false
local edgeKillerDelay = 3
local killerInRangeSince = nil
local predictiveCooldown = 0

local Dspeed = 5.6 -- you can tweak these numbers
local Ddelay = 0

local killerNames = {"c00lkidd", "Jason", "JohnDoe", "1x1x1x1", "Noli", "Slasher"}
local autoPunchOn = false
local messageWhenAutoPunchOn = false
local messageWhenAutoPunch = ""
local flingPunchOn = false
local flingPower = 10000
local hiddenfling = false
local aimPunch = false

local customBlockEnabled = false
local customBlockAnimId = ""
local customPunchEnabled = false
local customPunchAnimId = ""

-- delete for pc execs
local infiniteStamina = false
local espEnabled = false
local KillersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

local lastBlockTime = 0
local lastPunchTime = 0

local blockAnimIds = {
"72722244508749",
"96959123077498",
"95802026624883"
}
local punchAnimIds = {
"87259391926321",
"140703210927645",
"136007065400978",
"136007065400978",
"129843313690921",
"129843313690921",
"86709774283672",
"87259391926321",
"129843313690921",
"129843313690921",
"108807732150251",
"138040001965654",
"86096387000557",
"86096387000557"
}

local chargeAnimIds = {
    "106014898538300"
}

local customChargeEnabled = false
local customChargeAnimId = ""
local chargeAnimIds = { "106014898528300" }

-- Infinite Stamina (delete for pc execs)
local function enableInfiniteStamina()
    local success, StaminaModule = pcall(function()
        return require(game.ReplicatedStorage.Systems.Character.Game.Sprinting)
    end)
    if not success or not StaminaModule then return end

    StaminaModule.StaminaLossDisabled = true

    task.spawn(function()
        while infiniteStamina and StaminaModule do
            task.wait(0.1)
            StaminaModule.Stamina = StaminaModule.MaxStamina
            StaminaModule.StaminaChanged:Fire()
        end
    end)
end

local cachedAnimator = nil
local function refreshAnimator()
    local char = lp.Character
    if not char then
        cachedAnimator = nil
        return
    end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        local anim = hum:FindFirstChildOfClass("Animator")
        cachedAnimator = anim or nil
    else
        cachedAnimator = nil
    end
end

lp.CharacterAdded:Connect(function(char)
    task.wait(0.5) -- allow Humanoid/Animator to be created
    refreshAnimator()
end)

-- ===== performance improvements for Sound Auto Block =====
-- cached UI / refs
local cachedPlayerGui = PlayerGui
local cachedPunchBtn, cachedBlockBtn, cachedCharges, cachedCooldown, cachedChargeBtn, cachedCloneBtn = nil, nil, nil, nil, nil, nil
local detectionRangeSq = detectionRange * detectionRange

local function refreshUIRefs()
    -- ensure we have the most up-to-date references for MainUI and ability buttons
    cachedPlayerGui = lp:FindFirstChild("PlayerGui") or PlayerGui
    local main = cachedPlayerGui and cachedPlayerGui:FindFirstChild("MainUI")
    if main then
        local ability = main:FindFirstChild("AbilityContainer")
        cachedPunchBtn = ability and ability:FindFirstChild("Punch")
        cachedBlockBtn = ability and ability:FindFirstChild("Block")
        cachedChargeBtn = ability and ability:FindFirstChild("Charge")
        cachedCloneBtn = ability and ability:FindFirstChild("Clone")
        cachedCharges = cachedPunchBtn and cachedPunchBtn:FindFirstChild("Charges")
        cachedCooldown = cachedBlockBtn and cachedBlockBtn:FindFirstChild("CooldownTime")
    else
        cachedPunchBtn, cachedBlockBtn, cachedCharges, cachedCooldown, cachedChargeBtn, cachedCloneBtn = nil, nil, nil, nil, nil, nil
    end
end

-- call once at startup
refreshUIRefs()

-- refresh on GUI or character changes (keeps caches fresh)
if cachedPlayerGui then
    cachedPlayerGui.ChildAdded:Connect(function(child)
        if child.Name == "MainUI" then
            task.delay(0.02, refreshUIRefs)
        end
    end)
end

lp.CharacterAdded:Connect(function()
    task.delay(0.5, refreshUIRefs)
end)

NoticeTab:CreateParagraph({
    Title = "welcome",
    Content = "thanks for using my wonderful auto block script"
})

NoticeTab:CreateParagraph({
    Title = "",
    Content = "some features may only work with guest skins thats using the default anims"
})

NoticeTab:CreateParagraph({
    Title = "",
    Content = ".gg/Tmby2GkKJR"
})

-- GUI Toggles
AutoBlockTab:CreateToggle({
Name = "Auto Block (Animation)",
CurrentValue = false,
Flag = "AutoBlockAnimation",
Callback = function(Value) autoBlockOn = Value end
})

-- Rayfield toggle for Auto Block (Audio)
AutoBlockTab:CreateToggle({
    Name = "Auto Block (Audio)",
    CurrentValue = false,
    Flag = "AutoBlockAudio",
    Callback = function(state)
        autoBlockAudioOn = state
        if state then
            StarterGui:SetCore("SendNotification", {
                Title = "Auto Block Audio",
                Text = "Enabled - Press A to activate",
                Duration = 3
            })
        else
            StarterGui:SetCore("SendNotification", {
                Title = "Auto Block Audio",
                Text = "Disabled",
                Duration = 3
            })
            autoBlockOn = false
        end
    end,
})

-- make sure AutoBlockTab is a valid Rayfield tab object
local autoblocktype = "Block"

-- simple notification
local function SendNotif(title, text, duration)
    StarterGui:SetCore("SendNotification", {
        Title = title or "Hello",
        Text = text or "hi",
        Duration = duration or 4 -- seconds
    })
end

AutoBlockTab:CreateButton({
    Name = "Change auto block type",
    Callback = function()
        if autoblocktype == "Block" then
            autoblocktype = "Charge"
            SendNotif("changed auto block type", "CHARGE", 4)
        elseif autoblocktype == "Charge" then
            autoblocktype = "7n7 Clone"
            SendNotif("changed auto block type", "7N7 CLONE", 4)
        elseif autoblocktype == "7n7 Clone" then
            autoblocktype = "Block"
            SendNotif("changed auto block type", "BLOCK", 4)
        end
    end,
})

AutoBlockTab:CreateParagraph({
    Title = "Recomendation",
    Content = "use audio auto block and use 20 range for it"
})

AutoBlockTab:CreateToggle({
Name = "Message When Blocking",
CurrentValue = false,
Flag = "MessageWhenBlockToggle",
Callback = function(Value) messageWhenAutoBlockOn = Value end
})

AutoBlockTab:CreateInput({
    Name = "Message when blocking",
    PlaceholderText = "im gonna block ya",
    RemoveTextAfterFocusLost = false,
    Flag = "MessageWhenBlockText",
    Callback = function(Text) messageWhenAutoBlock = Text end
})

AutoBlockTab:CreateParagraph({
    Title = "notice",
    Content = "face check delays on coolkid, dont use face check agaisnt coolkid."
})

local facingCheckEnabled = true
local customFacingDot = -0.3

AutoBlockTab:CreateToggle({
    Name = "Enable Facing Check",
    CurrentValue = true,
    Flag = "FacingCheckToggle",
    Callback = function(Value)
        facingCheckEnabled = Value
    end
})

local function isFacing(localRoot, targetRoot)
    if not facingCheckEnabled then
        return true
    end

    local dir = (localRoot.Position - targetRoot.Position).Unit
    local dot = targetRoot.CFrame.LookVector:Dot(dir)
    return looseFacing and dot > customFacingDot
end

-- Optimized facing check
local function isFacing(localRoot, targetRoot)
    -- fast global reads
    local enabled = facingCheckEnabled
    if not enabled then return true end

    local loose = looseFacing

    -- difference vector (one allocation, unavoidable)
    local dx = localRoot.Position.X - targetRoot.Position.X
    local dy = localRoot.Position.Y - targetRoot.Position.Y
    local dz = localRoot.Position.Z - targetRoot.Position.Z

    -- magnitude (sqrt) once; handle zero-distance safely
    local mag = math.sqrt(dx*dx + dy*dy + dz*dz)
    if mag == 0 then
        -- if positions coincide treat as "facing" (matches permissive behavior)
        return true
    end
    local invMag = 1 / mag

    -- unit direction components (no new Vector3 allocation)
    local ux, uy, uz = dx * invMag, dy * invMag, dz * invMag

    -- cache look vector components
    local lv = targetRoot.CFrame.LookVector
    local lx, ly, lz = lv.X, lv.Y, lv.Z

    -- dot product (fast scalar math)
    local dot = lx * ux + ly * uy + lz * uz

    -- same logic as original, but explicit for clarity/branch prediction
    return dot > (customFacingDot or -0.3)
end

-- ===== Facing Check Visual (fixed) =====
local facingVisualOn = false
local facingVisuals = {} -- [killer] = visual

local function updateFacingVisual(killer, visual)
    if not (killer and visual and visual.Parent) then return end
    local hrp = killer:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    -- calculate angle from DOT threshold (safe-clamp)
    local dot = math.clamp(customFacingDot or -0.3, -1, 1)
    local angle = math.acos(dot)              -- radians, 0..pi
    local frac = angle / math.pi              -- 0..1 (0 = very narrow cone, 1 = very wide)

    -- scale radius between a small fraction and full detectionRange
    local minFrac = 0.20                      -- tune: smallest disc is 20% of detectionRange
    local radius = math.max(1, detectionRange * (minFrac + (1 - minFrac) * frac))
    visual.Radius = radius
    visual.Height = 0.12

    -- place the disc in front of the killer; move slightly less forward for narrow cones
    local forwardDist = detectionRange * (0.35 + 0.15 * frac) -- tune if you like
    local yOffset = -(hrp.Size.Y / 2 + 0.05)
    visual.CFrame = CFrame.new(0, yOffset, -forwardDist) * CFrame.Angles(math.rad(90), 0, 0)

    -- determine local player's HRP and whether they are inside range & facing
    local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    local inRange = false
    local facingOkay = false

    if myRoot and hrp then
        local dist = (hrp.Position - myRoot.Position).Magnitude
        inRange = dist <= detectionRange
        facingOkay = (not facingCheckEnabled) or (type(isFacing) == "function" and isFacing(myRoot, hrp))
    end

    -- color / transparency
    if inRange and facingOkay then
        visual.Color3 = Color3.fromRGB(0, 255, 0)
        visual.Transparency = 0.40
    else
        visual.Color3 = Color3.fromRGB(255, 255, 0) -- show yellow when not both conditions
        visual.Transparency = 0.85
    end
end

local function addFacingVisual(killer)
    if not killer or not killer:IsA("Model") then return end
    if facingVisuals[killer] then return end
    local hrp = killer:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local visual = Instance.new("CylinderHandleAdornment")
    visual.Name = "FacingCheckVisual"
    visual.Adornee = hrp
    visual.AlwaysOnTop = true
    visual.ZIndex = 2
    visual.Transparency = 0.55
    visual.Color3 = Color3.fromRGB(0, 255, 0) -- green

    visual.Parent = hrp
    facingVisuals[killer] = visual

    -- initialize placement immediately
    updateFacingVisual(killer, visual)
end

local function removeFacingVisual(killer)
    local v = facingVisuals[killer]
    if v then
        v:Destroy()
        facingVisuals[killer] = nil
    end
end

local function refreshFacingVisuals()
    for _, k in ipairs(KillersFolder:GetChildren()) do
        if facingVisualOn then
            -- make sure HRP exists before creating
            local hrp = k:FindFirstChild("HumanoidRootPart") or k:WaitForChild("HumanoidRootPart", 5)
            if hrp then addFacingVisual(k) end
        else
            removeFacingVisual(k)
        end
    end
end

-- keep visuals in sync every frame (ensures size/mode changes apply immediately)
RunService.RenderStepped:Connect(function()
    for killer, visual in pairs(facingVisuals) do
        -- if the killer was removed/died, clean up
        if not killer.Parent or not killer:FindFirstChild("HumanoidRootPart") then
            removeFacingVisual(killer)
        else
            updateFacingVisual(killer, visual)
        end
    end
end)

-- Keep visuals for newly added/removed killers
KillersFolder.ChildAdded:Connect(function(killer)
    if facingVisualOn then
        task.spawn(function()
            local hrp = killer:WaitForChild("HumanoidRootPart", 5)
            if hrp then addFacingVisual(killer) end
        end)
    end
end)
KillersFolder.ChildRemoved:Connect(function(killer) removeFacingVisual(killer) end)

-- toggle in GUI (keeps behaviour with dropdown)
AutoBlockTab:CreateToggle({
    Name = "Facing Check Visual",
    CurrentValue = false,
    Flag = "FacingCheckVisualToggle",
    Callback = function(state)
        facingVisualOn = state
        refreshFacingVisuals()
    end
})

AutoBlockTab:CreateParagraph({
    Title = "letsgo",
    Content = "facing check visual not being accurate is because its just there to give u an idea of the facing check"
})

AutoBlockTab:CreateInput({
Name = "Facing Check angle (DOT)",
PlaceholderText = "-0.3",
RemoveTextAfterFocusLost = false,
Flag = "Facingcheckdot",
Callback = function(Text)
customFacingDot = tonumber(Text) or customFacingDot
end
})

AutoBlockTab:CreateParagraph({
    Title = "DOT explanation",
    Content = "if for example you put it 0 you will need to be EXACTLY infront of the killer. but you can make the facing check cone larger by making it -0.3 or -0.5 if you put -1 is going to be a half circle cone infront the killer, so yeah."
})

AutoBlockTab:CreateInput({
Name = "Detection Range",
PlaceholderText = "18",
RemoveTextAfterFocusLost = false,
Flag = "DetectionRange",
Callback = function(Text)
detectionRange = tonumber(Text) or detectionRange
detectionRangeSq = detectionRange * detectionRange
end
})

-- ===== Facing Check Visual (paste after detectionCircles / addKillerCircle) =====
local detectionCircles = {} -- store all killer circles
local killerCirclesVisible = false

-- Function to add circle to a killer
-- replace your addKillerCircle with this
local function addKillerCircle(killer)
    if not killer:FindFirstChild("HumanoidRootPart") then return end
    if detectionCircles[killer] then return end

    local hrp = killer.HumanoidRootPart
    local circle = Instance.new("CylinderHandleAdornment")
    circle.Name = "KillerDetectionCircle"
    circle.Adornee = hrp
    circle.Color3 = Color3.fromRGB(255, 0, 0)
    circle.AlwaysOnTop = true
    circle.ZIndex = 1
    circle.Transparency = 0.6
    circle.Radius = detectionRange            -- <- use detectionRange exactly
    circle.Height = 0.12                      -- thin disc
    -- place the disc at the feet of the HumanoidRootPart (CFrame is relative to Adornee)
    local yOffset = -(hrp.Size.Y / 2 + 0.05)  -- a little below HRP origin
    circle.CFrame = CFrame.new(0, yOffset, 0) * CFrame.Angles(math.rad(90), 0, 0)
    circle.Parent = hrp

    detectionCircles[killer] = circle
end

-- Update radius when detectionRange changes (and on render)

-- Function to remove circle from a killer
local function removeKillerCircle(killer)
    if detectionCircles[killer] then
        detectionCircles[killer]:Destroy()
        detectionCircles[killer] = nil
    end
end

-- Refresh all circles
local function refreshKillerCircles()
    for _, killer in ipairs(KillersFolder:GetChildren()) do
        if killerCirclesVisible then
            addKillerCircle(killer)
        else
            removeKillerCircle(killer)
        end
    end
end

-- Keep radius updated
RunService.RenderStepped:Connect(function()
    for killer, circle in pairs(detectionCircles) do
        if circle and circle.Parent then
            circle.Radius = detectionRange
        end
    end
end)

-- Hook into killers being added/removed
KillersFolder.ChildAdded:Connect(function(killer)
    if killerCirclesVisible then
        task.spawn(function()
            -- Wait until HRP exists (max 5s timeout)
            local hrp = killer:WaitForChild("HumanoidRootPart", 5)
            if hrp then
                addKillerCircle(killer)
            end
        end)
    end
end)

KillersFolder.ChildRemoved:Connect(function(killer)
    removeKillerCircle(killer)
end)

-- Rayfield toggle
AutoBlockTab:CreateToggle({
    Name = "Range Visual",
    CurrentValue = false,
    Flag = "KillerCircleToggle",
    Callback = function(state)
        killerCirclesVisible = state
        refreshKillerCircles()
    end
})

BDTab:CreateParagraph({
    Title = "notice",
    Content = "BD or Better Detection delays on coolkid, use normal detection agaisnt coolkid."
})

BDTab:CreateToggle({
    Name = "Better Detection (doesn't use detectrange)",
    CurrentValue = false,
    Flag = "AntiFlickToggle",
    Callback = function(state)
        antiFlickOn = state
    end,
})

BDTab:CreateSlider({
    Name = "How many block parts that spawn",
    Range = {1, 16},       -- min,max parts the player can pick
    Increment = 1,         -- step size (integer only)
    Suffix = "parts",
    CurrentValue = 4,      -- default shown in UI
    Flag = "AntiFlickParts",
    Callback = function(val)
        antiFlickParts = math.max(1, math.floor(val))
    end,
})

BDTab:CreateSlider({
    Name = "Block Parts Size Multiplier",
    Range = {0.1, 5},      -- min 0.1x, max 5x
    Increment = 0.1,
    Suffix = "x",
    CurrentValue = 1,      -- default 1x
    Flag = "BlockPartsSizeMultiplier",
    Callback = function(val)
        blockPartsSizeMultiplier = tonumber(val) or 1
    end,
})

BDTab:CreateSlider({
    Name = "Forward Prediction Strength",
    Range = {0, 10},        -- 1x .. 10x
    Increment = 0.1,
    Suffix = "x",
    CurrentValue = 1,
    Flag = "PredictionStrength",
    Callback = function(val)
        predictionStrength = val
    end,
})

BDTab:CreateSlider({
    Name = "Turn Prediction Strength",
    Range = {0, 10},        -- 1x .. 10x
    Increment = 0.1,
    Suffix = "x",
    CurrentValue = 1,
    Flag = "PredictionTurnStrength",
    Callback = function(val)
        predictionTurnStrength = val
    end,
})

BDTab:CreateInput({
    Name = "delay before the first block part spawn (seconds) (DBTFBPS)",
    PlaceholderText = "0",
    RemoveTextAfterFocusLost = false,
    Flag = "AntiFlickDelay",
    Callback = function(text)
        local num = tonumber(text)
        if num then
            antiFlickDelay = math.max(0, num) -- don't allow negative
        end
    end,
})

-- ===== auto-adjust DBTFBPS based on killer (drop this after KillersFolder / BD inputs) =====

local function getNearestKillerModel()
    local myChar = lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end

    local closest, closestDist = nil, math.huge
    for _, k in ipairs(KillersFolder:GetChildren()) do
        if k and k:IsA("Model") then
            local hrp = k:FindFirstChild("HumanoidRootPart")
            if hrp then
                local d = (hrp.Position - myRoot.Position).Magnitude
                if d < closestDist then
                    closest, closestDist = k, d
                end
            end
        end
    end
    return closest
end

local function applyDelayForKillerModel(killerModel)
    if not killerModel then
        -- no killer found -> restore manual value
        if antiFlickDelay ~= _savedManualAntiFlickDelay then
            antiFlickDelay = _savedManualAntiFlickDelay
            print(("Auto-DBTFBPS: no killer -> restore antiFlickDelay = %s"):format(tostring(antiFlickDelay)))
        end
        return
    end

    local key = (tostring(killerModel.Name) or ""):lower()
    local mapped = killerDelayMap[key]

    if mapped ~= nil then
        if antiFlickDelay ~= mapped then
            antiFlickDelay = mapped
            print(("Auto-DBTFBPS: matched killer '%s' -> antiFlickDelay = %s"):format(killerModel.Name, tostring(mapped)))
        end
    else
        -- killer not in mapping: restore manual value (avoid surprising changes)
        if antiFlickDelay ~= _savedManualAntiFlickDelay then
            antiFlickDelay = _savedManualAntiFlickDelay
            print(("Auto-DBTFBPS: killer '%s' not mapped -> restore antiFlickDelay = %s"):format(killerModel.Name, tostring(_savedManualAntiFlickDelay)))
        end
    end
end

-- small throttled heartbeat loop (runs only when toggle enabled)
local adjustTicker = 0
RunService.Heartbeat:Connect(function(dt)
    if not autoAdjustDBTFBPS then return end
    adjustTicker = adjustTicker + dt
    if adjustTicker < 0.15 then return end -- check ~every 0.15s
    adjustTicker = 0

    local nearest = getNearestKillerModel()
    applyDelayForKillerModel(nearest)
end)

-- immediate update helper when killers spawn/leave or user toggles
local function doImmediateUpdate()
    if not autoAdjustDBTFBPS then return end
    local nearest = getNearestKillerModel()
    applyDelayForKillerModel(nearest)
end

-- respond quickly when killers are added/removed (so toggle reacts immediately)
KillersFolder.ChildAdded:Connect(function() task.delay(0.05, doImmediateUpdate) end)
KillersFolder.ChildRemoved:Connect(function() task.delay(0.05, doImmediateUpdate) end)

-- UI toggle to enable/disable the auto-adjust behavior (place this near other BDTab controls)
BDTab:CreateToggle({
    Name = "Auto-adjust DBTFBPS based on killer",
    CurrentValue = false,
    Flag = "AutoAdjustDBTFBPS",
    Callback = function(state)
        autoAdjustDBTFBPS = state
        if state then
            -- save the current manual value so we can restore it when the toggle is off
            _savedManualAntiFlickDelay = antiFlickDelay or 0
            doImmediateUpdate()
            print("Auto-DBTFBPS: enabled (saved manual antiFlickDelay = " .. tostring(_savedManualAntiFlickDelay) .. ")")
        else
            -- restore manual value when user disables
            antiFlickDelay = _savedManualAntiFlickDelay
            print("Auto-DBTFBPS: disabled -> restored antiFlickDelay = " .. tostring(antiFlickDelay))
        end
    end,
})
-- ===== end auto-adjust snippet =====


local stagger  = 0.02

BDTab:CreateInput({
    Name = "delay before each block parts spawns (seconds)",
    PlaceholderText = "0.02",
    RemoveTextAfterFocusLost = false,
    Flag = "AntiFlickDelayEachParts",
    Callback = function(text)
        local num = tonumber(text)
        if num then
            stagger = math.max(0, num) -- don't allow negative
        end
    end,
})

BDTab:CreateInput({
    Name = "how much studs infront killer the block parts are gonna spawn (studs)",
    PlaceholderText = "2.7",
    RemoveTextAfterFocusLost = false,
    Flag = "AntiFlickDistanceInfront",
    Callback = function(text)
        local num = tonumber(text)
        if num then
            antiFlickBaseOffset = math.max(0, num) -- don't allow negative
        end
    end,
})

TechTab:CreateToggle({
    Name = "Double Punch Tech",
    CurrentValue = false,
    Flag = "doubleblockTechtoggle",
    Callback = function(state)
        doubleblocktech = state
    end,
})

-- Hitbox Dragging Tech
local hitboxDraggingTech = false
local _hitboxDraggingDebounce = false
local HITBOX_DRAG_DURATION = 1.4
local HITBOX_DETECT_RADIUS = 6

TechTab:CreateToggle({
    Name = "Hitbox Dragging tech (HDT)",
    CurrentValue = false,
    Flag = "HitboxDraggingToggle",
    Callback = function(state)
        hitboxDraggingTech = state
    end,
})

TechTab:CreateInput({
    Name = "HDT speed",
    PlaceholderText = "5.6",
    RemoveTextAfterFocusLost = false,
    Flag = "HDTspeed",
    Callback = function(Text) Dspeed = Text end
})

TechTab:CreateInput({
    Name = "HDT delay",
    PlaceholderText = "0",
    RemoveTextAfterFocusLost = false,
    Flag = "HDTdelay",
    Callback = function(Text) Ddelay = Text end
})

TechTab:CreateParagraph({
    Title = "Hitbox Dragging tech",
    Content = "i reccomend using a high detection range (if using normal detection) when using this"
})

TechTab:CreateButton({
    Name = "Fake Lag Tech",
    Callback = function()
        pcall(function()
            local char = lp.Character or lp.CharacterAdded:Wait()
            local humanoid = char and char:FindFirstChildOfClass("Humanoid")
            if not humanoid then return end

            local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)

            -- (optional) stop any identical track already playing
            for _, t in ipairs(animator:GetPlayingAnimationTracks()) do
                local id = tostring(t.Animation and t.Animation.AnimationId or ""):match("%d+")
                if id == "136252471123500" then
                    pcall(function() t:Stop() end)
                end
            end

            local anim = Instance.new("Animation")
            anim.AnimationId = "rbxassetid://136252471123500"
            local track = animator:LoadAnimation(anim)
            track:Play()
        end)
    end,
})

PredictiveTab:CreateToggle({
    Name = "Predictive Auto Block",
    CurrentValue = false,
    Callback = function(Value)
        predictiveBlockOn = Value
    end,
})

PredictiveTab:CreateInput({
    Name = "Detection Range",
    PlaceholderText = "10",
    RemoveTextAfterFocusLost = false,
    Callback = function(text)
        local num = tonumber(text)
        if num then
            detectionRange = num
        end
    end,
})

PredictiveTab:CreateSlider({
    Name = "Edge Killer",
    Range = {0, 7},
    Increment = 0.1,
    CurrentValue = 3,
    Flag = "edgekillerlmao",
    Callback = function(val)
        edgeKillerDelay = val
    end,
})

PredictiveTab:CreateParagraph({
    Title = "Edge Killer",
    Content = "how many secs until it blocks (resets when killer gets out of range)"
})

FakeBlockTab:CreateButton({
    Name = "Load Fake Block",
    Callback = function()
        pcall(function()
            local fakeGui = PlayerGui:FindFirstChild("FakeBlockGui")
            if not fakeGui then
                local success, result = pcall(function()
                    return loadstring(game:HttpGet("https://raw.githubusercontent.com/skibidi399/Auto-block-script/refs/heads/main/fakeblock"))()
                end)
                if not success then
                    warn("❌ Failed to load Fake Block GUI:", result)
                end
            else
                fakeGui.Enabled = true
                print("✅ Fake Block GUI enabled")
            end
        end)
    end,
})

AutoPunchTab:CreateToggle({
Name = "Auto Punch",
CurrentValue = false,
Flag = "AutoPunchToggle",
Callback = function(Value) autoPunchOn = Value end
})

AutoPunchTab:CreateToggle({
Name = "Message When Punching",
CurrentValue = false,
Flag = "MessageWhenPunchToggle",
Callback = function(Value) messageWhenAutoPunchOn = Value end
})

AutoPunchTab:CreateInput({
    Name = "Message when punching",
    PlaceholderText = "Im not gonna sugarcoat it.",
    RemoveTextAfterFocusLost = false,
    Flag = "MessageWhenPunchText",
    Callback = function(Text) messageWhenAutoPunch = Text end
})

AutoPunchTab:CreateToggle({
Name = "Fling Punch",
CurrentValue = false,
Callback = function(Value) flingPunchOn = Value end
})

AutoPunchTab:CreateToggle({
Name = "Punch Aimbot",
CurrentValue = false,
Flag = "PunchAimToggle",
Callback = function(Value) aimPunch = Value end
})

local predictionValue = 4

AutoPunchTab:CreateSlider({
    Name = "Aim Prediction",
    Range = {0, 10},
    Increment = 0.1,
    Suffix = "studs",
    CurrentValue = predictionValue,
    Flag = "PredictionSlider",
    Callback = function(Value)
        predictionValue = Value
    end,
})

AutoPunchTab:CreateSlider({
Name = "Fling Power",
Range = {5000, 50000000000000},
Increment = 1000000,
CurrentValue = 10000,
Flag = "FlingPower",
Callback = function(Value) flingPower = Value end
})

-- Custom Block Animation
CustomAnimationsTab:CreateInput({
    Name = "Custom Block Animation",
    PlaceholderText = "AnimationId",
    RemoveTextAfterFocusLost = false,
    Flag = "customblockid",
    Callback = function(Text) customBlockAnimId = Text end
})

CustomAnimationsTab:CreateToggle({
Name = "Enable Custom Block Animation",
CurrentValue = false,
Callback = function(Value) customBlockEnabled = Value end
})

CustomAnimationsTab:CreateInput({
    Name = "Custom Punch Animation (not for M3/M4)",
    PlaceholderText = "AnimationId",
    RemoveTextAfterFocusLost = false,
    Flag = "custompunchid",
    Callback = function(Text) customPunchAnimId = Text end
})

CustomAnimationsTab:CreateToggle({
Name = "Enable Custom Punch Animation",
CurrentValue = false,
Callback = function(Value) customPunchEnabled = Value end
})

CustomAnimationsTab:CreateInput({
    Name = "Charge Animation ID",
    PlaceholderText = "Put animation ID here",
    RemoveTextAfterFocusLost = false,
    Flag = "customchargeid",
    Callback = function(input)
        customChargeAnimId = input
    end,
})

CustomAnimationsTab:CreateToggle({
    Name = "Custom Charge Animation",
    CurrentValue = false,
    Callback = function(value)
        customChargeEnabled = value
    end,
})

-- Button to run Infinite Yield
MiscTab:CreateButton({
    Name = "Run Infinite Yield",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    end,
})

-- Control Charge: only watch sounds that are descendants of the local player's character
-- ===== Full Control Charge block using noli void rush override behavior =====
-- Assumes your script already requires RunService and Players in the file,
-- but this block gets its own references so it can be pasted standalone.

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

-- Detector IDs table (use existing chargeAnimIds if available)
local detectorChargeIds = (type(chargeAnimIds) == "table" and chargeAnimIds) or {}

-- Optional: detect a custom charge anim id (if you already use these vars elsewhere)
-- set customChargeEnabled = true and customChargeAnimId = "123456" elsewhere in your script to detect custom anim too
-- local customChargeEnabled = false
-- local customChargeAnimId = ""

-- Override speed (same as your noli script)
local ORIGINAL_DASH_SPEED = 60

-- Toggle / runtime state
local controlChargeEnabled = false
local controlChargeActive = false
local overrideConnection = nil

-- Save/restore for humanoid original values
local savedHumanoidState = {}

local function getHumanoid()
    if not lp or not lp.Character then return nil end
    return lp.Character:FindFirstChildOfClass("Humanoid")
end

local function saveHumState(hum)
    if not hum then return end
    if savedHumanoidState[hum] then return end
    local s = {}
    pcall(function()
        s.WalkSpeed = hum.WalkSpeed
        -- support either JumpPower or JumpHeight
        local ok, _ = pcall(function() s.JumpPower = hum.JumpPower end)
        if not ok then
            pcall(function() s.JumpPower = hum.JumpHeight end)
        end
        -- AutoRotate might not exist on all Humanoids; try to capture if possible
        local ok2, ar = pcall(function() return hum.AutoRotate end)
        if ok2 then s.AutoRotate = ar end
        s.PlatformStand = hum.PlatformStand
    end)
    savedHumanoidState[hum] = s
end

local function restoreHumState(hum)
    if not hum then return end
    local s = savedHumanoidState[hum]
    if not s then return end
    pcall(function()
        if s.WalkSpeed ~= nil then hum.WalkSpeed = s.WalkSpeed end
        if s.JumpPower ~= nil then
            local ok, _ = pcall(function() hum.JumpPower = s.JumpPower end)
            if not ok then pcall(function() hum.JumpHeight = s.JumpPower end) end
        end
        if s.AutoRotate ~= nil then pcall(function() hum.AutoRotate = s.AutoRotate end) end
        if s.PlatformStand ~= nil then hum.PlatformStand = s.PlatformStand end
    end)
    savedHumanoidState[hum] = nil
end

-- Start the override (forces dash movement similar to noli void rush)
local function startOverride()
    if controlChargeActive then return end
    local hum = getHumanoid()
    if not hum then return end

    controlChargeActive = true
    saveHumState(hum)

    -- Make sure humanoid is set to dash state
    pcall(function()
        hum.WalkSpeed = ORIGINAL_DASH_SPEED
        hum.AutoRotate = false
    end)

    -- RenderStepped connection to force forward movement every frame (like your noli function)
    overrideConnection = RunService.RenderStepped:Connect(function()
        local humanoid = getHumanoid()
        local rootPart = humanoid and humanoid.Parent and humanoid.Parent:FindFirstChild("HumanoidRootPart")
        if not humanoid or not rootPart then return end

        -- ensure speed + autorotate each frame (helps if some other code fights it)
        pcall(function()
            humanoid.WalkSpeed = ORIGINAL_DASH_SPEED
            humanoid.AutoRotate = false
        end)

        local direction = rootPart.CFrame.LookVector
        local horizontal = Vector3.new(direction.X, 0, direction.Z)
        if horizontal.Magnitude > 0 then
            humanoid:Move(horizontal.Unit)
        else
            humanoid:Move(Vector3.new(0,0,0))
        end
    end)
end

-- Stop the override and restore humanoid state
local function stopOverride()
    if not controlChargeActive then return end
    controlChargeActive = false

    -- disconnect override loop
    if overrideConnection then
        pcall(function() overrideConnection:Disconnect() end)
        overrideConnection = nil
    end

    -- restore humanoid fields
    local hum = getHumanoid()
    if hum then
        pcall(function()
            -- restore saved values if present
            restoreHumState(hum)
            -- ensure we stop movement
            humanoid:Move(Vector3.new(0,0,0))
        end)
    end
end

-- Internal detection: look for playing anim tracks that match charge IDs or custom ID
local function detectChargeAnimation()
    local hum = getHumanoid()
    if not hum then return false end
    for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
        local ok, animId = pcall(function()
            return tostring(track.Animation and track.Animation.AnimationId or ""):match("%d+")
        end)
        if ok and animId and animId ~= "" then
            if detectorChargeIds and table.find(detectorChargeIds, animId) then
                return true
            end
            if (type(customChargeEnabled) == "boolean" and customChargeEnabled) and customChargeAnimId and tostring(customChargeAnimId) ~= "" then
                if tostring(animId) == tostring(customChargeAnimId) then
                    return true
                end
            end
        end
    end
    return false
end

-- Public toggle control
local function ControlCharge_SetEnabled(val)
    controlChargeEnabled = val and true or false
    if not controlChargeEnabled and controlChargeActive then
        stopOverride()
    end
end

-- Main loop: check detection each RenderStepped (uses same cadence as noli script)
RunService.RenderStepped:Connect(function()
    if not controlChargeEnabled then
        if controlChargeActive then stopOverride() end
        return
    end

    -- If humanoid dies or character resets, ensure override cleared
    local hum = getHumanoid()
    if not hum then
        if controlChargeActive then stopOverride() end
        return
    end

    local isCharging = detectChargeAnimation()

    if isCharging then
        if not controlChargeActive then
            startOverride()
        end
    else
        if controlChargeActive then
            stopOverride()
        end
    end
end)

-- Keep humanoid state fresh on CharacterAdded
lp.CharacterAdded:Connect(function(char)
    -- small wait to let Humanoid exist
    task.spawn(function()
        local hum = char:WaitForChild("Humanoid", 2)
        if hum then
            -- optionally prime saved state (not necessary)
        end
    end)
end)

-- Expose toggle function globally for other script parts or for hotkeys
_G.ControlCharge_SetEnabled = ControlCharge_SetEnabled

-- Example usage:
-- _G.ControlCharge_SetEnabled(true)  -- enable detection/override
-- _G.ControlCharge_SetEnabled(false) -- disable
-- =======================================================================

-- Rayfield GUI for Control Charge (paste near your other CustomAnimationsTab UI code)
-- Requires CustomAnimationsTab from your Rayfield Window (already present in your big script)

-- initialize global defaults so the control block can read them
_G.ControlCharge_DashSpeed = _G.ControlCharge_DashSpeed or 60
_G.ControlCharge_CustomEnabled = _G.ControlCharge_CustomEnabled or false
_G.ControlCharge_CustomAnimId = _G.ControlCharge_CustomAnimId or ""

-- Toggle: enable / disable the control charge monitoring
MiscTab:CreateToggle({
    Name = "Control Charge",
    CurrentValue = false,
    Callback = function(val)
        -- call the setter your control block exposes
        if _G.ControlCharge_SetEnabled then
            pcall(function() _G.ControlCharge_SetEnabled(val) end)
        else
            -- fallback: store desired state so the control block can pick it up if it reads _G later
            _G.ControlCharge_WantedEnabled = val
        end
    end,
})

-- Message below the button
MiscTab:CreateParagraph({
    Title = "Tip",
    Content = 'Run Infinite Yield and type "antifling" so punch fling works better.'
})

-- delete for pc execs
MiscTab:CreateToggle({
    Name = "Infinite Stamina",
    CurrentValue = false,
    Flag = "InfStamina",
    Callback = function(value)
        infiniteStamina = value
        if infiniteStamina then
            enableInfiniteStamina()
        else
            local success, StaminaModule = pcall(function()
                return require(game.ReplicatedStorage.Systems.Character.Game.Sprinting)
            end)
            if success and StaminaModule then
                StaminaModule.StaminaLossDisabled = false
            end
        end
    end,
})

local function addESP(obj)
    if not obj:IsA("Model") then return end
    if not obj:FindFirstChild("HumanoidRootPart") then return end

    local plr = Players:GetPlayerFromCharacter(obj)
    if not plr then return end -- ✅ only add ESP if it's a player character

    -- Prevent duplicates
    if obj:FindFirstChild("ESP_Highlight") then return end

    -- Highlight
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight"
    highlight.FillColor = Color3.fromRGB(255, 0, 0)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Adornee = obj
    highlight.Parent = obj

    -- Billboard
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_Billboard"
    billboard.Size = UDim2.new(0, 100, 0, 50)
    billboard.AlwaysOnTop = true
    billboard.Adornee = obj:FindFirstChild("HumanoidRootPart")
    billboard.Parent = obj

    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "ESP_Text"
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
    textLabel.TextScaled = true
    textLabel.Font = Enum.Font.SourceSansBold
    textLabel.Text = obj.Name
    textLabel.Parent = billboard
end

-- Function to clear ESP
local function clearESP(obj)
    if obj:FindFirstChild("ESP_Highlight") then
        obj.ESP_Highlight:Destroy()
    end
    if obj:FindFirstChild("ESP_Billboard") then
        obj.ESP_Billboard:Destroy()
    end
end

-- Function to refresh all ESP
local function refreshESP()
    if not espEnabled then
        for _, killer in pairs(KillersFolder:GetChildren()) do
            clearESP(killer)
        end
        return
    end

    for _, killer in pairs(KillersFolder:GetChildren()) do
        addESP(killer)
    end
end

-- Modify ChildAdded connection:
KillersFolder.ChildAdded:Connect(function(child)
    if espEnabled then
        task.wait(0.1) -- wait for HRP
        addESP(child)
    end
end)

KillersFolder.ChildRemoved:Connect(function(child)
    clearESP(child)
end)

-- Distance updater
RunService.RenderStepped:Connect(function()
    if not espEnabled then return end
    local char = lp.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    for _, killer in pairs(KillersFolder:GetChildren()) do
        local billboard = killer:FindFirstChild("ESP_Billboard")
        if billboard and billboard:FindFirstChild("ESP_Text") and killer:FindFirstChild("HumanoidRootPart") then
            local dist = (killer.HumanoidRootPart.Position - hrp.Position).Magnitude
            billboard.ESP_Text.Text = string.format("%s\n[%d]", killer.Name, dist)
        end
    end
end)

MiscTab:CreateToggle({
    Name = "Killer ESP",
    CurrentValue = false,
    Flag = "KillerESP_Toggle",
    Callback = function(Value)
        espEnabled = Value
        refreshESP()
    end,
})

-- === KEYBIND TAB ===

-- Status Keybind
KeybindTab:CreateParagraph({
    Title = "Keybind Status",
    Content = keybindEnabled and "ENABLED" or "DISABLED"
})

-- Toggle untuk mengaktifkan keybind
KeybindTab:CreateToggle({
    Name = "Enable Keybind Controller",
    CurrentValue = false,
    Flag = "KeybindEnabled",
    Callback = function(Value)
        keybindEnabled = Value
        
        -- Update status paragraph
        KeybindTab:CreateParagraph({
            Title = "Keybind Status",
            Content = keybindEnabled and "ENABLED" or "DISABLED"
        })
        
        if Value then
            SendNotif("Keybind Controller", "Enabled - Press A to activate auto block", 3)
            -- Notifikasi untuk mobile
            if UserInputService.TouchEnabled then
                StarterGui:SetCore("SendNotification", {
                    Title = "Mobile Mode",
                    Text = "Tap the red button to toggle auto block",
                    Duration = 3
                })
            end
        else
            SendNotif("Keybind Controller", "Disabled", 3)
            autoBlockOn = false
        end
    end,
})

-- Toggle untuk tombol mobile
KeybindTab:CreateToggle({
    Name = "Mobile Button",
    CurrentValue = true,
    Flag = "MobileButton",
    Callback = function(Value)
        mobileButtonEnabled = Value
        if Value then
            if UserInputService.TouchEnabled and not mobileButton then
                createMobileButton()
            end
            SendNotif("Mobile Button", "Enabled", 2)
        else
            if mobileButton then
                mobileButton:Destroy()
                mobileButton = nil
            end
            SendNotif("Mobile Button", "Disabled", 2)
        end
    end,
})

-- Informasi keybind
KeybindTab:CreateParagraph({
    Title = "Current Keybind",
    Content = tostring(autoBlockKey.Name)
})

KeybindTab:CreateParagraph({
    Title = "Instructions",
    Content = "PC: Press " .. tostring(autoBlockKey.Name) .. " to toggle\nMobile: Tap the red button"
})

KeybindTab:CreateParagraph({
    Title = "Mobile Instructions",
    Content = "• Tap button to toggle auto block\n• Hold button for 1 second to change keybind\n• Button is draggable"
})

-- Visual indicator
KeybindTab:CreateParagraph({
    Title = "Visual Indicator",
    Content = "Button turns GREEN when auto block is active\nButton turns RED when auto block is inactive"
})

-- Button to change keybind
KeybindTab:CreateButton({
    Name = "Change Keybind (PC)",
    Callback = function()
        -- Show notification to press a new key
        SendNotif("Keybind Change", "Press the key you want to use for Auto Block", 5)
        
        -- Wait for user input
        local connection
        connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            
            -- Make sure input is a keyboard key
            if input.UserInputType == Enum.UserInputType.Keyboard then
                -- Update keybind
                autoBlockKey = input.KeyCode
                
                -- Update notification
                SendNotif("Keybind Changed", "New keybind: " .. tostring(autoBlockKey.Name), 3)
                
                -- Disconnect connection
                connection:Disconnect()
                
                -- Update UI
                KeybindTab:CreateParagraph({
                    Title = "Current Keybind",
                    Content = tostring(autoBlockKey.Name)
                })
                
                -- Update mobile button text if exists
                if mobileButton then
                    mobileButton.Text = tostring(autoBlockKey.Name)
                end
            end
        end)
    end,
})

-- Button untuk mobile keybind changer
KeybindTab:CreateButton({
    Name = "Change Keybind (Mobile)",
    Callback = function()
        if UserInputService.TouchEnabled then
            changeKeybindDialog()
        else
            SendNotif("Not Mobile", "This feature is for mobile users only", 3)
        end
    end,
})

-- Status mobile
KeybindTab:CreateParagraph({
    Title = "Device Status",
    Content = UserInputService.TouchEnabled and "MOBILE DETECTED" or "PC DETECTED"
})

-- Helpers
local function fireRemoteBlock()
local args = {"UseActorAbility", "Block"}
ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
end

local function fireRemotePunch()
local args = {"UseActorAbility", "Punch"}
ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
end

-- Push *into* the killer (drops in for doLegitBlockTP_withVelocity)

local function playCustomAnim(animId, isPunch)
    if not Humanoid then
        warn("Humanoid missing")
        return
    end

    if not animId or animId == "" then
        warn("No animation ID provided")
        return
    end

    local now = tick()
    local lastTime = isPunch and lastPunchTime or lastBlockTime
    if now - lastTime < 1 then
        return
    end

    -- Stop other known anims
    for _, track in ipairs(Humanoid:GetPlayingAnimationTracks()) do
        local animNum = tostring(track.Animation.AnimationId):match("%d+")
        if table.find(isPunch and punchAnimIds or blockAnimIds, animNum) then
            track:Stop()
        end
    end

    -- Create and load the animation
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://" .. animId

    local animator = Humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", Humanoid)
    local track = animator:LoadAnimation(anim)

    track:Play()

    if isPunch then
        lastPunchTime = now
    else
        lastBlockTime = now
    end

    return track
end

-- Ensure the character is loaded
local function ensureCharacter()
    if not lp.Character then
        lp.CharacterAdded:Wait()
    end
    return lp.Character
end

-- Get the character's humanoid
local function getHumanoid()
    local char = ensureCharacter()
    return char and char:FindFirstChildOfClass("Humanoid")
end

-- Get the character's humanoid root part
local function getHumanoidRootPart()
    local char = ensureCharacter()
    return char and char:FindFirstChild("HumanoidRootPart")
end

-- Check if a killer is within range
local function isKillerInRange(killer, range)
    local myHRP = getHumanoidRootPart()
    local killerHRP = killer and killer:FindFirstChild("HumanoidRootPart")
    
    if not myHRP or not killerHRP then
        return false
    end
    
    local distance = (myHRP.Position - killerHRP.Position).Magnitude
    return distance <= range
end

-- Check if killer is facing the player
local function isKillerFacingPlayer(killer)
    local myHRP = getHumanoidRootPart()
    local killerHRP = killer and killer:FindFirstChild("HumanoidRootPart")
    
    if not myHRP or not killerHRP then
        return false
    end
    
    local direction = (myHRP.Position - killerHRP.Position).Unit
    local dot = killerHRP.CFrame.LookVector:Dot(direction)
    return dot > (customFacingDot or -0.3)
end

-- Main auto block function
local function autoBlock()
    if not autoBlockOn then return end
    
    local myHRP = getHumanoidRootPart()
    if not myHRP then return end
    
    for _, killerName in ipairs(killerNames) do
        local killer = KillersFolder:FindFirstChild(killerName)
        if killer and isKillerInRange(killer, detectionRange) and isKillerFacingPlayer(killer) then
            -- Block the attack
            fireRemoteBlock()
            
            -- Play custom animation if enabled
            if customBlockEnabled and customBlockAnimId ~= "" then
                playCustomAnim(customBlockAnimId, false)
            end
            
            -- Send message if enabled
            if messageWhenAutoBlockOn and messageWhenAutoBlock ~= "" then
                SendNotif("Auto Block", messageWhenAutoBlock, 1)
            end
            
            break -- Only block one killer at a time
        end
    end
end

-- Main auto punch function
local function autoPunch()
    if not autoPunchOn then return end
    
    local myHRP = getHumanoidRootPart()
    if not myHRP then return end
    
    for _, killerName in ipairs(killerNames) do
        local killer = KillersFolder:FindFirstChild(killerName)
        if killer and isKillerInRange(killer, detectionRange) then
            -- Punch the killer
            fireRemotePunch()
            
            -- Play custom animation if enabled
            if customPunchEnabled and customPunchAnimId ~= "" then
                playCustomAnim(customPunchAnimId, true)
            end
            
            -- Fling punch if enabled
            if flingPunchOn then
                local killerHRP = killer:FindFirstChild("HumanoidRootPart")
                if killerHRP then
                    local start = tick()
                    while tick() - start < 1 do
                        if myHRP and killerHRP and killerHRP.Parent then
                            local frontPos = killerHRP.Position + (killerHRP.CFrame.LookVector * 2)
                            myHRP.CFrame = CFrame.new(frontPos, killerHRP.Position)
                        end
                        task.wait()
                    end
                end
            end
            
            -- Send message if enabled
            if messageWhenAutoPunchOn and messageWhenAutoPunch ~= "" then
                SendNotif("Auto Punch", messageWhenAutoPunch, 1)
            end
            
            break -- Only punch one killer at a time
        end
    end
end

-- Main loop
RunService.Heartbeat:Connect(function()
    autoBlock()
    autoPunch()
end)

-- Load configuration
Rayfield:LoadConfiguration()
